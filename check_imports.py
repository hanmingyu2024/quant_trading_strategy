"""
检查项目中的Python包依赖
用于分析项目中导入的包与已安装包的差异
"""

import ast
import os
import pkg_resources
from typing import Dict, Set, Tuple


def get_project_imports() -> Tuple[Set[str], Dict[str, str]]:
    """获取项目中的导入"""
    # 扩展系统内置模块和内部模块列表
    stdlib_modules = set((
        'os', 'sys', 'time', 'datetime', 'json', 'math', 'random', 'logging', 
        're', 'collections', 'typing', 'pathlib', 'shutil', 'tempfile', 'io',
        'ast', 'abc', 'argparse', 'base64', 'contextlib', 'enum', 'secrets',
        'dataclasses', 'subprocess', 'threading', 'uuid', 'concurrent',
        'email', 'queue', 'sqlite3', 'ssl', 'hashlib', 'base', 'smtplib',
        'platform', 'traceback'
    ))
    
    # 扩展项目内部模块列表
    project_modules = set((
        'utils', 'config', 'backend', 'modules', 'tools', 'data_handler',
        'mt5_connector', 'auth_middleware', 'database', 'app', 'models',
        'schemas', 'services', 'api', 'error_handler_middleware',
        'monitoring', 'logger', 'trade_executor', 'logging_middleware',
        'rate_limit_middleware'
    ))
    
    imports = set()
    import_locations = {}
    
    for root, dirs, files in os.walk('.'):
        if any(x in root for x in ['.venv', '__pycache__', '.git']):
            continue
            
        for file in files:
            if file.endswith('.py'):
                file_path = os.path.join(root, file)
                try:
                    with open(file_path, 'r', encoding='utf-8') as f:
                        try:
                            tree = ast.parse(f.read())
                            for node in ast.walk(tree):
                                if isinstance(node, ast.Import):
                                    for name in node.names:
                                        pkg_name = name.name.split('.')[0]
                                        if pkg_name not in stdlib_modules and pkg_name not in project_modules:
                                            imports.add(pkg_name)
                                            import_locations[pkg_name] = import_locations.get(pkg_name, []) + [file_path]
                                elif isinstance(node, ast.ImportFrom):
                                    if node.module:
                                        pkg_name = node.module.split('.')[0]
                                        if pkg_name not in stdlib_modules and pkg_name not in project_modules:
                                            imports.add(pkg_name)
                                            import_locations[pkg_name] = import_locations.get(pkg_name, []) + [file_path]
                        except SyntaxError:
                            continue
                except Exception:
                    continue
    
    return imports, import_locations


def get_installed_packages() -> Dict[str, str]:
    """获取已安装的包"""
    return {pkg.key: pkg.version for pkg in pkg_resources.working_set}


def update_requirements():
    """更新 requirements.txt"""
    imports, locations = get_project_imports()
    installed = get_installed_packages()
    
    # 需要排除的包
    excluded_packages = {
        'check_structure',
        'aliyunsdkrds',
        'aliyunsdkcore',
        'flatted',
        'logging_middleware',  # 添加到排除列表
        'rate_limit_middleware'  # 添加到排除列表
    }
    
    # 过滤掉需要排除的包
    imports = {pkg for pkg in imports if pkg not in excluded_packages}
    
    # 包分类和版本限制（适配 Python 3.9）
    categories = {
        'Web 框架': [
            'fastapi==0.68.2',  # 固定版本
            'uvicorn==0.15.0',
            'starlette==0.14.2'
        ],
        'Data': [
            'pandas==1.3.5',  # Python 3.9 兼容版本
            'numpy==1.21.6'
        ],
        'Database': [
            'sqlalchemy==1.4.41',
            'pymysql==1.0.2',
            'alembic==1.7.7'
        ],
        'Utils': [
            'python-dotenv==0.19.2',
            'requests==2.26.0',
            'pydantic==1.8.2',  # Python 3.9 兼容版本
            'pydantic-settings==1.2.2'
        ],
        'Trading': [
            'MetaTrader5==5.0.37'
        ],
        'Security': [
            'python-jose[cryptography]==3.3.0',
            'passlib[bcrypt]==1.7.4',
            'python-multipart==0.0.5'
        ]
    }
    
    # 写入 requirements.txt
    with open('requirements.txt', 'w', encoding='utf-8') as f:
        f.write("# Generated by check_imports.py\n")
        f.write("# Compatible with Python 3.9\n\n")
        
        for category, packages in categories.items():
            f.write(f"# {category}\n")
            for pkg in packages:
                pkg_name = pkg.split('==')[0]
                if pkg_name in imports:
                    f.write(f"{pkg}\n")
            f.write("\n")
        
        # 写入其他包
        other_packages = []
        for pkg in imports:
            if not any(pkg.split('==')[0] in p for cat in categories.values() for p in cat):
                if pkg in installed:
                    other_packages.append(f"{pkg}=={installed[pkg]}")
                else:
                    other_packages.append(pkg)
        
        if other_packages:
            f.write("# Other dependencies\n")
            for pkg in sorted(other_packages):
                f.write(f"{pkg}\n")


if __name__ == "__main__":
    print("正在分析项目依赖...")
    update_requirements()
    print("\n✅ requirements.txt 已更新!")
    print("执行以下命令安装所有依赖：")
    print("pip install -r requirements.txt")
